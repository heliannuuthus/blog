- 单个线程的问题

  - 通常使用就直接创建，使用完毕后自动销毁。
  - 系统资源是有限的，没办法无上限的创建线程，并且频繁的创建和销毁线程会消耗系统资源。
  - 所以最好的方法就是将其**池化**。

  > 线程池可以管理和复用线程，使用完线程后不会立即销毁，而是将其放入线程池中，等待下一次使用。

- 线程池的创建

  - 使用 `Executors` 工具类创建线程池（不推荐，不是无界阻塞队列就是无限工作线程数）
  - 使用 `ThreadPoolExecutor` 创建线程池。

- 线程池的参数和动态配置化

  - 线程池的参数

    - `corePoolSize` 核心线程数。
    - `maximumPoolSize` 最大线程数，当**阻塞队列**填满之后，会创建**工作线程**，直到达到最大线程数。
    - `keepAliveTime` 线程空闲时间，当**工作线程**空闲时间超过这个时间，线程会被销毁。
    - `unit` 线程空闲时间单位。
    - `workQueue` 阻塞队列，用于存储等待执行的任务。
    - `threadFactory` 线程工厂，用于自定义线程创建的逻辑。
    - `handler` 拒绝策略，当工作队列满了之后，新的任务如何处理的逻辑。
      - `AbortPolicy` 直接抛出异常。
      - `CallerRunsPolicy` 由调用者执行任务，可能发生主线程的阻塞。
      - `DiscardPolicy` 直接丢弃任务，用户无感知的数据丢失。
      - `DiscardOldestPolicy` 丢弃最老的任务，用户无感知的数据丢失。
      - **Netty** 中使用 `new Thread(Runnable, String)` 方法创建新线程，承接任务。
      - **ActiveMQ** 中使用 使用延时入队的策略，等待一段时间后，如果线程池有空闲线程时，再执行任务。


:::tip 线程池参数的一些特性

    - 初始化的线程池中线程数为 0，**当有任务提交时，才会创建工作线程**，不过可以通过 `preStartXXX` 方法**提前创建核心线程**。
    - 为了保证线程池的线程活性，当前线程池内**线程数小于到核心线程数**时，**不会复用空闲线程**。
    - 动态设置线程池参数，可以使用 `ThreadPoolExecutor` 的 `setter` 方法，但是**无法动态设置阻塞队列**。
      - 针对设置核心线程数，如果当前线程池中**线程数小于核心线程数**，会**销毁掉多余的线程**。


:::

- 线程池处理异常线程

  - 使用 `execute` 方法执行任务时，如果任务执行过程中发生异常，**线程池会重新创建线程**，并将异常记录到堆栈。
  - 使用 `submit` 方法提交任务时，线程池会返回一个 `Future` 对象，错误信息会记录到 `Future` 对象中。

> 抽象队列同步器（AbstractQueuedSynchronizer），是 Java 层面实现**锁**和其他**同步组件**的基础框架。

- AQS 原理

  > - 当线程请求共享资源时，将当前线程设置为当前资源的工作线程，将当前资源设置为锁定状态。
  > - 当请求共享资源被占用时，将当前线程加入到等待队列中。

  - 使用 **CLH** 虚拟双端队列来管理等待线程。
    - 这个队列并不存在，而是由内部 `Node` 构成，通过 `nextWaiter` 指针连接。
    - 单个节点表示一个线程，节点内部维护了**线程的引用**、**线程的状态(waitStatus)**、等待线程的**前驱(prev)**和**后继节点(next)**。
    - 队列中有存在 **head** 和 **tail** 节点，分别表示队列的头和尾。
    - 队列的入队和出队操作都是通过 `CAS` 来实现的。
  - 使用 `volatile int state` 类型的变量表示同步状态，通过 **CAS** 修改状态。

- AQS 常用实现

  - **ReentrantLock**
    - 使用 `state` 表示锁的**持有次数(为 0 表示未被锁定)**。
    - 存在 **公平锁** 和 **非公平锁** 两种实现。
    - 是可中断的
      - `synchronized` 是不可中断的，一旦获取就只能等待锁释放。
      - 可中断的锁，在等待过程中可以被中断，不一定非要等待锁释放。
    - 基于 `Condition` 实现线程的等待和唤醒。
      - 底层是 `LockSupport` 类，通过 `park` 和 `unpark` 方法。
      - 提供的 `newCondition` 方法可以创建多个 `Condition` (内含**等待队列**)，唤醒时可以**批量分组唤醒**。
      - 该功能在 `synchronized` 中无法实现，可以理解为**所有的线程都注册在一个 `Condition` 上**。
  - **CountDownLatch**
    - 同时能存在多少个线程执行任务，**仅能使用一次**。
  - **Semaphore**
    - 指定一个共享资源**同时能被多少个线程访问**。
  - **CyclicBarrier**
    - 和 `CountDownLatch` 类似，但是可以**重复使用**，并且可以在**计数器达到指定值**时执行指定操作。
  - **LockSupport**
    - 用于线程的**阻塞**和**唤醒**。
    - 底层是 `Unsafe` 类，通过 `park` 和 `unpark` 方法。

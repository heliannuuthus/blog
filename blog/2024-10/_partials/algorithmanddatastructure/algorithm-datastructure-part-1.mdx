## 数组

### 数据结构

> 二维数组在某些语言内的存储可能是**不连续**的

1. 存储：**连续内存**，根据不同的语言可能实现稍有不同
   - 连续内存意味着，_方便查询，难于删除和插入_
2. 查询：根据索引可**直接获取**
3. 增删：需要**挪动索引位置往后的所有元素**

### 算法思路

> 介绍了二分查找，双指针（包括遍历双指针，滑动窗口，遍历填充），前缀和

#### 二分查找

1. 循环不变量：在循环中，某些值是可以确定的，这些值不会随着循环改变
2. 二分查找的**区间定义**十分重要，通常为`左闭右开`或者`左闭右闭`
   - `左闭右开`：
     - 对于 `left == right` 的条件是**没意义**的
     - 如果右区间缩短，可调整为 right = middle
   - `左闭右闭`：
     - 对于 `left == right` 的条件是**有意义**的
     - 如果右区间缩短，可调整为 right = middle - 1
3. 二分查找可用于**寻找边界**，能迅速缩短区间范围

#### 双指针

1. **快慢指针**：多用于删除元素，覆盖元素
2. **滑动窗口**：单层 for 循环一定是滑动窗口的`终止指针`，而左边则是`动态（起始）指针`
   - 确定窗口内是什么？
   - 如何移动起始指针？
   - 如何移动终止指针？
3. **遍历填充**：
   - 多用于画各种螺旋矩阵，四边依次遍历然后调整边界即可。
   - 注意跳出的条件，在`非中心对称的矩阵`中可于`每次调整边界`时判断返回条件

#### 前缀和

1. 多用于**重复计算**的场景，或者是存在`回溯依赖条件`的计算

## 链表

### 数据结构

> 分为单链表，双链表以及循环链表

1. 存储：可不连续内存
2. 查询：需遍历索引之前的元素
3. 增删：直接删除或添加即可

### 算法思路

#### 虚拟头节点

针对`单独处理头节点`的特殊场景都可以使用虚拟头节点将头节点**归一化**

#### [设计链表](https://leetcode.cn/problems/design-linked-list/description)

可使用 `head` 以及 `tail` 增加效率（难度有所上升，但是效率较高）

- `head` 为 dummy 单链表节点
- `tail` 为 dummy 双链表节点，当然也可以将 `next` 视为 `prev`
- 添加 `length` 规避无效操作

#### [翻转链表](https://leetcode.cn/problems/reverse-linked-list/description)

1. 思路一：递归回溯
   1. 递归到最后方的节点作为 head 返回
   2. 到下一层重置 next 为 current
   3. 最外层重置 next 为 null，否则是循环链表，没有 null
2. 思路二：三指针正序遍历
   1. 将 prev 指定为 null，当前操作链表节点指定为 current ，next 为 current.next
   2. 将 current.next 指向 prev，将 current 指向 next 开始下一轮遍历
   3. 在每次遍历结束时更新 prev 为 current，current 为 next
   4. 每次遍历开始时更新 next 为 current.next

#### [两两交换链表邻近节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description)

- 单节点不用判断，故而需要得知下两个节点的情况
- 借助 dummy node，可实现头部的转换
  1. 将 current.next 指向 next.next（即下次交换的点）
  2. 将 next.next 指向 current
  3. 将 prev.next 指向 next
  4. 将 prev 指向 current 进入下次循环

#### [删除链表的倒数第 N 个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description)

1. 思路一：快慢指针
   1. _将 fast 前移 N + 1 个节点处（+1 是为了方便删除）_
   2. 移动 fast 和 slow，当 fast 到达 NULL 节点时 slow.next 即为删除的元素
2. 思路二：递归回溯
   1. 递归到最后方的节点，开始返回，并且减少 n 的值（数倒数第几个）
   2. 数到 n + 1 时可停下，current.next 即为待删除的节点

#### [链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists/description)

> _这道题很抽象，感觉很多条件都有边界，但是实际又没有_

1. 遍历两个链表获得长度差值，利用快慢指针
2. 两个链表一起遍历，如果遇到一样的值可直接返回（题中提到不会有环型链表，故而不用在意后面是否还有相同的数）

#### [环形链表](https://leetcode.cn/problems/linked-list-cycle/description)

> 重点在于公式的推导，利用快慢指针可解

1. 设置快慢指针 `fast` 和 `slow`，`fast` 步长为 2，`slow` 步长为 1
2. 设 `x` 表示从 `head` 到环入口的长度
3. 设 `y` 表示从环入口到快慢指针相遇点的距离
4. 设 `z` 表示环的总长度
5. 由于快指针速度是慢指针的 2 倍，相遇时快指针走过的距离是慢指针的 2 倍，推导以下公式：

   $$
   x = head \rightarrow entry, \space y = entry \rightarrow meet, \space z = circle \space length
   $$

   $$
   \begin{align}
   & x + y + z = 2(x + y) \\
   & x + y + z = 2x + 2y \\
   & z = x + y \\
   & x = z - y
   \end{align}
   $$

   即慢指针跑完一圈，刚好是慢指针从 head 到入口的距离

## 字符串

> _这对这个版本的我来说，库函数都是在害我（打基础 ing）_

### 数据结构

1. 存储：**连续内存**，Java 11 及以下版本是 `char[]`，Java 11 及以上版本是 `byte[]`
2. 查询：根据索引可**直接获取**
3. 增删：需要**挪动索引位置往后的所有元素**
4. Java 中字符串是**不可变**的，_每次操作都会生成新的字符串_

### 算法思路

#### 双指针

1. 判断是否可以使用双指针，字符串转 `char[]` **原地操作**
   - _类似反转字符串，旋转字符串等_
2. 填充类可以**预先计算总长**，观察是否会存在破坏性填充（_数组的插入是需要成本的_）
   - _可观察是否可以从后向前填充_
3. 反转类对寻找规律，判断边界如果跳过记得在下一行 cover 住

#### KMP

> _这个我好像看懂了，反复观摩了很多遍。短期记忆内理解这个问题不大_

1. 搞清楚**前缀后缀**分别是什么
   - 前缀：除了字符串的最后一个字符其他的顺序子串
   - 后缀：除了字符串的第一个字符其他的顺序子串
2. 最长相等前后缀是什么？有什么用？怎么用？
   - 是什么：记录着当前位置目标串与模式串匹配失败时，目标串回退的位置
   - 有什么用：在不回退模式串的情况下，回退目标串即可继续匹配
   - 怎么用：匹配失败的时候搞个 `while` 循环回退一下

:::tip
在我看 [LeetCode-459 题解](https://leetcode.cn/problems/repeated-substring-pattern/solutions/)的时候（看了将近一天时间），深刻的了解了上面的全部概念，在 carl 哥的训导以及 LeetCode 官方的指教下看明白了。

carl 哥更多的是以一种最容易懂的方式讲题

LeetCode 官方题解直接上数学概念（不过不怎么难，也就看了那么 1234 遍吧）。

短期内我肯定还会反复看，加深映像以及彻底理解 KMP。
:::

## 栈与队列

### 数据结构

> 底层的实现通常是**数组、链表或堆**，其中堆最优

1. 栈：先进后出，针对 Java 内栈的实现，底层是数组，`Stack` 类继承了 `Vector` 类，内部均为同步方法，**不推荐使用**
2. 队列：先进先出，针对 Java 内队列的实现，底层是链表或者数组
   - `LinkedList` 类继承了 `Queue` 类，内部为链表实现
   - `ArrayDeque` 类继承了 `Deque` 类，内部为数组实现

### 算法思路

#### [括号匹配](https://leetcode.cn/problems/valid-parentheses/description)

1. 括号匹配问题通常使用**栈**来解决，因为栈的先进后出特性，可以方便地解决成对出现的括号

#### [字符串去重](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description)

1. 双指针去重也是匹配问题，通过当前元素与栈顶元素比较，相同则出栈，不同则入栈
   - 社区提供了一套**原地覆盖**的方法：
     - 快指针遍历，进入循环时快指针赋值给慢指针
     - 慢指针判断当前位置和前一位置值是否相同（重复）
     - 相同即回退，不同即前进，快指针每次遍历都前进
     - 最后慢指针的位置即为去重后的字符串长度

#### [单调队列](https://leetcode.cn/problems/sliding-window-maximum/description)

1. 单调队列的本质是**空间换时间**，通过记录元素的索引，在遍历过程中将不符合条件的元素出栈
2. 通常结合**滑动窗口**，用于寻找区间内的最大值、最小值等
3. 分为两种类型：
   - 单调递增队列：
     - 队列内元素从队首到队尾是递增的
     - 遇到比队尾元素大的元素，则从队尾开始出队
   - 单调递减队列：
     - 队列内元素从队首到队尾是递减的
     - 遇到比队尾元素小的元素，则从队尾开始出队

#### [优先级队列](https://leetcode.cn/problems/top-k-frequent-elements/description)

1. 优先级队列的本质是**堆**，通过堆的性质快速找到最大值或最小值
2. 通常用于热点数据查找、前 K 大数据等场景
3. 优先级队列的**三种实现方式**及其复杂度：

| 数据结构 | 查询时间复杂度 | 插入时间复杂度 |
| :------: | :------------: | :------------: |
|   数组   |    **O(1)**    |     _O(n)_     |
|   链表   |     _O(n)_     |    **O(1)**    |
|  树(堆)  |  **O(logn)**   |  **O(logn)**   |

:::tip
Java 中优先级队列：

- 使用 `PriorityQueue` 实现，默认为**小顶堆**
- _可通过 `Comparator` 实现大顶堆_
- 复合类型建议：
  - _重写 `equals` 和 `hashCode` 方法_
  - _或使用数组存储复合元素_
    :::
